//! Exec-based feature installer for compose containers
//!
//! For compose-based devcontainers, features can't be baked into images at build time
//! (the build is managed by `docker compose up --build`). Instead, we copy each feature
//! into the running container and run its install.sh via exec.

use crate::Result;
use devc_provider::{ContainerId, ContainerProvider, ExecConfig};
use std::collections::HashMap;
use tokio::sync::mpsc;

use super::resolve::ResolvedFeature;

/// Install features into a running container via exec.
///
/// For each feature:
/// 1. Copy the feature directory into the container at `/tmp/dev-container-feature/`
/// 2. Run `install.sh` with the feature's options as environment variables
/// 3. Clean up the temporary directory
///
/// After all features are installed, write any `containerEnv` entries to
/// `/etc/profile.d/devc-features.sh` so they persist across sessions.
pub async fn install_features_via_exec(
    provider: &dyn ContainerProvider,
    container_id: &ContainerId,
    features: &[ResolvedFeature],
    remote_user: &str,
    progress: Option<&mpsc::UnboundedSender<String>>,
) -> Result<()> {
    let mut all_container_env: Vec<(String, String)> = Vec::new();

    for (i, feature) in features.iter().enumerate() {
        let short_name = feature
            .id
            .rsplit_once('/')
            .map(|(_, n)| n)
            .unwrap_or(&feature.id);

        if let Some(tx) = progress {
            let _ = tx.send(format!(
                "Installing feature {}/{}: {}...",
                i + 1,
                features.len(),
                short_name
            ));
        }

        // 1. Copy feature files into the container
        provider
            .copy_into(container_id, &feature.dir, "/tmp/dev-container-feature")
            .await?;

        // 2. Build environment variables
        let env = build_feature_env(&feature.options, remote_user);

        // 3. Run install.sh
        let exec_config = ExecConfig {
            cmd: vec![
                "sh".to_string(),
                "-c".to_string(),
                "chmod +x /tmp/dev-container-feature/install.sh \
                 && cd /tmp/dev-container-feature \
                 && /tmp/dev-container-feature/install.sh \
                 && rm -rf /tmp/dev-container-feature/"
                    .to_string(),
            ],
            env,
            user: Some("root".to_string()),
            ..Default::default()
        };

        let result = provider.exec(container_id, &exec_config).await?;

        if result.exit_code != 0 {
            return Err(crate::CoreError::ExecFailed(format!(
                "Feature install '{}' failed (exit code {}): {}",
                feature.id, result.exit_code, result.output
            )));
        }

        // 4. Collect containerEnv entries
        if let Some(ref container_env) = feature.metadata.container_env {
            for (key, value) in container_env {
                all_container_env.push((key.clone(), value.clone()));
            }
        }
    }

    // Write all containerEnv entries to a profile script
    if !all_container_env.is_empty() {
        write_container_env(provider, container_id, &all_container_env).await?;
    }

    Ok(())
}

/// Build the environment variable map for running a feature's install.sh.
///
/// This mirrors the env var construction in `dockerfile.rs:generate_feature_layer()`:
/// - Feature options are uppercased (e.g., `version` â†’ `VERSION`)
/// - `_REMOTE_USER` and `_REMOTE_USER_HOME` are always set
pub fn build_feature_env(
    options: &HashMap<String, String>,
    remote_user: &str,
) -> HashMap<String, String> {
    let mut env = HashMap::new();

    for (key, value) in options {
        env.insert(key.to_uppercase(), value.clone());
    }

    let remote_user_home = if remote_user == "root" {
        "/root".to_string()
    } else {
        format!("/home/{}", remote_user)
    };

    env.insert("_REMOTE_USER".to_string(), remote_user.to_string());
    env.insert("_REMOTE_USER_HOME".to_string(), remote_user_home);

    env
}

/// Write containerEnv entries to `/etc/profile.d/devc-features.sh` so they
/// persist across shell sessions.
async fn write_container_env(
    provider: &dyn ContainerProvider,
    container_id: &ContainerId,
    env_entries: &[(String, String)],
) -> Result<()> {
    let mut script = String::from("#!/bin/sh\n# Generated by devc - feature containerEnv\n");
    for (key, value) in env_entries {
        // Use double quotes to allow variable expansion (e.g., $PATH)
        let escaped = value.replace('\\', "\\\\").replace('"', "\\\"");
        script.push_str(&format!("export {}=\"{}\"\n", key, escaped));
    }

    let exec_config = ExecConfig {
        cmd: vec![
            "sh".to_string(),
            "-c".to_string(),
            format!(
                "mkdir -p /etc/profile.d && cat > /etc/profile.d/devc-features.sh << 'DEVC_EOF'\n{}\nDEVC_EOF\nchmod +x /etc/profile.d/devc-features.sh",
                script
            ),
        ],
        user: Some("root".to_string()),
        ..Default::default()
    };

    provider.exec(container_id, &exec_config).await?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_feature_env_empty_options() {
        let env = build_feature_env(&HashMap::new(), "vscode");
        assert_eq!(env.get("_REMOTE_USER").unwrap(), "vscode");
        assert_eq!(env.get("_REMOTE_USER_HOME").unwrap(), "/home/vscode");
        assert_eq!(env.len(), 2);
    }

    #[test]
    fn test_build_feature_env_with_options() {
        let mut options = HashMap::new();
        options.insert("version".to_string(), "20".to_string());
        options.insert("nodeGypDependencies".to_string(), "true".to_string());

        let env = build_feature_env(&options, "dev");
        assert_eq!(env.get("VERSION").unwrap(), "20");
        assert_eq!(env.get("NODEGYPDEPENDENCIES").unwrap(), "true");
        assert_eq!(env.get("_REMOTE_USER").unwrap(), "dev");
        assert_eq!(env.get("_REMOTE_USER_HOME").unwrap(), "/home/dev");
    }

    #[test]
    fn test_build_feature_env_root_user() {
        let env = build_feature_env(&HashMap::new(), "root");
        assert_eq!(env.get("_REMOTE_USER").unwrap(), "root");
        assert_eq!(env.get("_REMOTE_USER_HOME").unwrap(), "/root");
    }
}
